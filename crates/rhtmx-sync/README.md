# rhtmx-sync

Automatic IndexedDB synchronization for RHTMX applications with **minimal developer code**.

## Features

- ✅ **Zero-config sync**: Add one derive macro, get automatic sync
- ✅ **Offline support**: Mutations queue when offline, sync when online
- ✅ **Real-time updates**: WebSocket (bidirectional) or SSE (fallback)
- ✅ **Conflict resolution**: Last-write-wins, client-wins, server-wins strategies
- ✅ **Field-level sync**: CRDT-like field granularity (like Yjs/Automerge)
- ✅ **Type-safe**: Rust's type system ensures correctness
- ✅ **Lightweight client**: ~12 KB JavaScript (no external dependencies)
- ✅ **Works with existing code**: No changes to your HTMX templates

## Quick Start

### 1. Add to your project

```toml
[dependencies]
rhtmx-sync = { path = "../rhtmx-sync" }
```

### 2. Add `#[derive(Syncable)]` to your models

```rust
use rhtmx_sync::Syncable;

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow, Syncable)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}
```

### 3. Initialize SyncEngine in main.rs

```rust
use rhtmx_sync::{SyncEngine, SyncConfig};

#[tokio::main]
async fn main() {
    let db_pool = init_db("sqlite://app.db").await?;

    // Create sync engine
    let sync_engine = SyncEngine::new(SyncConfig::new(
        db_pool.clone(),
        vec!["users".to_string()],  // Entities to sync
    )).await?;

    // Add routes to your app
    let app = Router::new()
        .merge(your_routes())
        .merge(sync_engine.routes());  // Adds /api/sync/*

    axum::serve(listener, app).await?;
}
```

### 4. Add script tag to your HTML layout

```html
<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <!-- Add rhtmx-sync script -->
    <script src="/api/sync/client.js"
            data-sync-entities="users"
            data-debug="true">
    </script>
</head>
<body>
    <!-- Your normal HTMX code -->
    <div id="users"
         hx-get="/api/users"
         hx-trigger="load, rhtmx:users:changed from:body">
        <!-- User list -->
    </div>
</body>
</html>
```

### 5. That's it! ✨

Your app now has:
- Automatic IndexedDB caching
- Real-time updates via SSE
- Offline support with mutation queueing
- Conflict resolution

## How It Works

```
┌─────────────────┐      SSE Stream       ┌──────────────────┐
│  SQLite (Server)│ ───────────────────► │ IndexedDB (Client)│
│                 │                       │                   │
│  1. DB changes  │   JSON over HTTP      │  3. Cache updated │
│  2. Log tracked │ ◄──────────────────── │  4. UI refreshed  │
└─────────────────┘   Offline mutations   └──────────────────┘
```

1. **Server detects changes**: `#[derive(Syncable)]` auto-tracks all DB mutations
2. **SSE broadcasts**: Real-time updates sent to all connected clients
3. **IndexedDB syncs**: Client library updates local cache
4. **UI refreshes**: HTMX triggers update affected elements
5. **Offline mutations**: Queue locally, sync when reconnected

## API Reference

### Server-Side

#### `#[derive(Syncable)]`

```rust
#[derive(Syncable)]
#[sync(
    table = "users",                    // Optional: table name
    strategy = SyncStrategy::LastWriteWins,  // Conflict resolution
)]
pub struct User {
    pub id: i32,
    pub name: String,
}
```

#### `SyncEngine`

```rust
let engine = SyncEngine::new(SyncConfig {
    db_pool: pool.clone(),
    entities: vec!["users", "posts"],
    strategy: SyncStrategy::LastWriteWins,
    debug: true,
}).await?;

// Get routes
let routes = engine.routes();

// Manual cleanup
engine.cleanup(7).await?;  // Clean up logs older than 7 days
```

### Client-Side

#### Script Tag Configuration

```html
<script src="/api/sync/client.js"
        data-sync-entities="users,posts,comments"
        data-conflict-strategy="last-write-wins"
        data-debug="true">
</script>
```

#### JavaScript API

```javascript
// Access the sync instance
window.rhtmxSync.syncEntity('users');  // Manual sync
window.rhtmxSync.log('message');       // Debug logging

// Listen for events
document.addEventListener('rhtmx:sync:ready', () => {
    console.log('Sync initialized');
});

document.addEventListener('rhtmx:users:changed', (e) => {
    console.log('User changed:', e.detail.id);
});
```

## HTTP Endpoints

Auto-generated by `SyncEngine`:

### `GET /api/sync/:entity?since=:version`

Get changes since a specific version.

**Response:**
```json
{
    "entity": "users",
    "version": 42,
    "changes": [
        {
            "id": 1,
            "action": "update",
            "data": { "id": 1, "name": "Alice" },
            "version": 42
        }
    ]
}
```

### `POST /api/sync/:entity`

Push client changes to server.

**Request:**
```json
{
    "changes": [
        {
            "id": "1",
            "action": "create",
            "data": { "name": "Bob" }
        }
    ]
}
```

### `GET /api/sync/events` (SSE)

Real-time event stream.

### `GET /api/sync/client.js`

Serves the JavaScript client library.

## Conflict Resolution

### Strategies

```rust
pub enum SyncStrategy {
    LastWriteWins,   // Default: newest timestamp wins
    ClientWins,      // Client changes always win
    ServerWins,      // Server changes always win
}
```

### Custom Resolvers

```rust
impl ConflictResolver<Document> for MyResolver {
    fn resolve(&self, server: Document, client: Document) -> Document {
        // Your custom merge logic
        merge_documents(server, client)
    }
}
```

## Examples

See `examples/todo_sync.rs` for a complete working example.

Run with:
```bash
cargo run --example todo_sync
```

## Bundle Size

- Client JavaScript: ~12 KB gzipped
- No external dependencies
- Works with all modern browsers

## Browser Compatibility

- Chrome/Edge: ✅
- Firefox: ✅
- Safari: ✅
- Opera: ✅

Requires:
- IndexedDB support
- EventSource (SSE) support
- ES6+ JavaScript

## Performance

- Incremental sync (not full table dumps)
- Connection pooling for database
- Broadcast for SSE (minimal memory)
- Automatic cleanup of old sync logs

## Limitations

- SQLite only (PostgreSQL support planned)
- Simple conflict resolution (CRDTs planned)
- 50MB IndexedDB quota (browser default)

## Field-Level Sync (New!)

rhtmx-sync now supports **field-level synchronization** similar to Yjs and Automerge. This allows fine-grained conflict resolution at the field level instead of syncing entire entities.

### Quick Start with Field-Level Sync

#### 1. Enable field-level sync in your config

```rust
use rhtmx_sync::{SyncEngine, SyncConfig, FieldMergeStrategy};

let sync_engine = SyncEngine::new(
    SyncConfig::new(db_pool.clone(), vec!["users".to_string()])
        .with_field_sync(FieldMergeStrategy::LastWriteWins)
).await?;
```

#### 2. Use the field-level sync client

```html
<script src="/api/sync/field-client.js"
        data-sync-entities="users"
        data-field-strategy="last-write-wins"
        data-debug="true">
</script>
```

#### 3. Track field changes from JavaScript

```javascript
// Record a field change
window.RHTMXFieldSync.recordFieldChange('users', '1', 'name', 'Alice');

// Listen for field-level conflicts
window.addEventListener('rhtmx:field:conflict', (e) => {
    console.log('Field conflict:', e.detail);
});
```

### Field Merge Strategies

```rust
pub enum FieldMergeStrategy {
    LastWriteWins,  // Timestamp-based (default)
    KeepBoth,       // Report conflict, let app decide
    ServerWins,     // Always prefer server value
    ClientWins,     // Always prefer client value
}
```

### Field-Level API Endpoints

When field-level sync is enabled, these additional endpoints are available:

- `GET /api/field-sync/:entity?since=:version` - Get field changes
- `POST /api/field-sync/:entity` - Push field changes
- `GET /api/field-sync/:entity/:entity_id/latest` - Get latest field values
- `GET /api/sync/field-client.js` - Field sync JavaScript client

### Benefits of Field-Level Sync

1. **Fine-grained conflict resolution**: Two users can edit different fields simultaneously without conflicts
2. **Reduced bandwidth**: Only changed fields are transmitted
3. **Better user experience**: Less chance of losing work due to conflicts
4. **CRDT-like behavior**: Similar to Yjs, Automerge for collaborative editing

## WebSocket Support (New!)

rhtmx-sync now supports **WebSocket** for bidirectional real-time sync, which is more efficient than SSE.

### Benefits of WebSocket over SSE

1. **Bidirectional**: Push and pull through same connection (SSE is one-way)
2. **Lower overhead**: Single persistent connection vs SSE + HTTP POST
3. **Better for real-time sync**: Immediate updates both ways
4. **More resource efficient**: Less connections, less bandwidth

### WebSocket Endpoints

When you add sync routes, both WebSocket and SSE endpoints are available:

- **WebSocket (preferred)**: `ws://localhost:3000/api/sync/ws` - Entity-level sync
- **WebSocket (field-level)**: `ws://localhost:3000/api/field-sync/ws` - Field-level sync
- **SSE (fallback)**: `GET /api/sync/events` - For browsers without WebSocket

### WebSocket Protocol

#### Entity-Level Sync Messages

```json
// Client subscribes to entities
{"type": "subscribe", "entities": ["users", "posts"]}

// Client requests sync
{"type": "sync", "entity": "users", "since": 42}

// Server sends change
{"type": "change", "change": {...}}

// Client pushes change
{"type": "push", "entity": "users", "entity_id": "1", "action": "update", "data": {...}}

// Server acknowledges
{"type": "push_ack", "entity": "users", "entity_id": "1", "version": 43}
```

#### Field-Level Sync Messages

```json
// Client pushes field changes
{
  "type": "push_fields",
  "entity": "users",
  "entity_id": "1",
  "fields": [
    {"field": "name", "value": "Alice", "action": "update", "timestamp": "2024-01-01T12:00:00Z"}
  ]
}

// Server sends field change
{"type": "field_change", "change": {...}}

// Server acknowledges with conflict info
{"type": "push_ack", "entity": "users", "entity_id": "1", "applied": 3, "conflicts": 1}
```

## Multi-Tab Sync (New!)

rhtmx-sync now supports **multi-tab synchronization** using the BroadcastChannel API. This allows tabs in the same browser to share sync state instantly without server round-trips.

### How It Works

When one tab receives an update (via WebSocket or makes a local change), it broadcasts to all other tabs:

1. **Automatic Broadcasting**: Changes received from server are automatically broadcast to other tabs
2. **Optimistic Updates**: Local changes are immediately shared with other tabs
3. **No Server Round-Trip**: Tabs communicate directly via BroadcastChannel
4. **Infinite Loop Prevention**: Each tab has a unique ID and ignores its own broadcasts

### Benefits

- **Instant UI sync**: All tabs stay in sync in real-time
- **Reduced server load**: Tabs don't need to poll or wait for server notifications
- **Better UX**: Users see consistent state across all tabs
- **Zero configuration**: Automatically enabled when BroadcastChannel is available

### Browser Support

BroadcastChannel is supported in all modern browsers (Chrome, Firefox, Safari, Edge). The library gracefully degrades if not available.

## Roadmap

- [ ] PostgreSQL support (LISTEN/NOTIFY)
- [ ] CRDT integration (Automerge)
- [x] Field-level sync (not just entity-level) ✅
- [x] WebSocket option (alternative to SSE) ✅
- [x] Multi-tab sync (BroadcastChannel) ✅
- [ ] Compression for large payloads
- [ ] Batch sync optimization

## License

MIT

## Contributing

Contributions welcome! Please open an issue first to discuss changes.
